        while self.app._run:
            self.app.motor.odrv0.axis0.watchdog_feed()

            # Date
            self.app.ui.date_label.setText(QtCore.QDateTime.currentDateTime().toString('yyyy-MM-dd hh:mm:ss'))

            self.app.motor.odrv0.axis0.watchdog_feed()

            # Stopwatch
            if self.app._stopwatch_state == StopwatchStates.RUNNING:
                self.app._stopwatch = time.time() - self.app._stopwatch_start_time
                self.app._lap = time.time() - self.app._stopwatch_lap_time
            elif self.app._stopwatch_state == StopwatchStates.PAUSED:
                self.app._stopwatch = self.app._stopwatch_pause_time - self.app._stopwatch_start_time
                self.app._lap = self.app._stopwatch_pause_time - self.app._stopwatch_lap_time
            elif self.app._stopwatch_state == StopwatchStates.STOPPED:
                self.app._stopwatch = 0.0
                self.app._lap = 0.0

            minutes = int(self.app._stopwatch // 60)  # get the integer part of the quotient
            seconds = int(self.app._stopwatch % 60)  # get the integer part of the remainder
            milliseconds = int((self.app._stopwatch - int(self.app._stopwatch)) * 100)  # get the milliseconds component
            self.app.ui.stopwatch_lcdNumber.display(f"{minutes:02d}:{seconds:02d}.{milliseconds:02d}")
            minutes = int(self.app._lap // 60)  # get the integer part of the quotient
            seconds = int(self.app._lap % 60)  # get the integer part of the remainder
            self.app.ui.lap_lcdNumber.display(f"{minutes:02d}:{seconds:02d}")

            self.app.motor.odrv0.axis0.watchdog_feed()

            # Save data
            if self.app._saving:
                if self.app._comment_to_save:
                    comment = self.app._comment
                    self.app._comment_to_save = False
                else:
                    comment = ""
                self.app.motor.save_data_to_file(
                    self.app._file_name,
                    spin_box=self.app.spin_box,
                    instruction=self.app.instruction,
                    ramp_instruction=self.app.ramp_instruction,
                    comment=comment,
                    stopwatch=self.app._stopwatch,
                    lap=self.app._lap,
                )

            self.app.motor.odrv0.axis0.watchdog_feed()

            # Display data
            self.app.ui.power_lineEdit.setText(f"{self.app.motor.get_user_power():.0f}")
            self.app.ui.velocity_lineEdit.setText(f"{self.app.motor.get_velocity():.0f}")
            self.app.ui.torque_lineEdit.setText(f"{self.app.motor.get_user_torque():.0f}")
            self.app.ui.turns_lineEdit.setText(f"{self.app.motor.get_turns():.0f}")
            self.app.ui.errors_label.setText(
                f"{traduce_error(self.app.motor.odrv0.error, ODriveError)}"
                f"{traduce_error(self.app.motor.odrv0.axis0.error, ODriveAxisError)}"
                f"{traduce_error(self.app.motor.odrv0.axis0.controller.error, ODriveControllerError)}"
                f"{traduce_error(self.app.motor.odrv0.axis0.encoder.error, ODriveEncoderError)}"
                f"{traduce_error(self.app.motor.odrv0.axis0.motor.error, ODriveMotorError)}"
                f"{traduce_error(self.app.motor.odrv0.axis0.sensorless_estimator.error, ODriveSensorlessEstimatorError)}"
                f"{traduce_error(self.app.motor.odrv0.can.error, ODriveCanError)}"
                f"brake resistor armed: {self.app.motor.odrv0.brake_resistor_armed}, "
                f"brake resistor saturated: {self.app.motor.odrv0.brake_resistor_saturated}, "
                f"brake resistor current: {self.app.motor.odrv0.brake_resistor_current:.2f}"
            )

            self.app.motor.odrv0.axis0.watchdog_feed()

            # Adapt the control of the motor accordingly to the current velocity and torque
            control_mode = self.app.motor.get_control_mode()
            # If the motor is in torque control, the torque input needs to be updated in function of the velocity
            # because of the resisting torque.
            # Furthermore, it allows to stop the pedals by reducing the torque if the user has stopped.
            if control_mode == ControlMode.TORQUE_CONTROL:
                self.app.instruction = self.app.motor.torque_control(self.app.spin_box, self.app.ramp_instruction)

            # The power control mode is based on the torque control mode, but the torque input is calculated from the
            # current velocity (torque_input = power / velocity and resiting torque).
            elif control_mode == ControlMode.POWER_CONTROL:
                self.app.instruction = self.app.motor.power_control(self.app.spin_box, self.app.ramp_instruction)

            # The linear control mode is based on the torque control mode, but the torque input is calculated from the
            # current velocity (torque_input = linear_coeff * velocity and resiting torque).
            elif control_mode == ControlMode.LINEAR_CONTROL:
                self.app.instruction = self.app.motor.linear_control(self.app.spin_box, self.app.ramp_instruction)

            elif control_mode == ControlMode.ECCENTRIC_POWER_CONTROL:
                self.app.instruction = self.app.motor.eccentric_power_control(self.app.spin_box, self.app.ramp_instruction)

            elif self.app.motor.get_control_mode() == ControlMode.STOPPING:
                if abs(motor.get_velocity()) < 10.0:
                    self.app.motor.stopped()
                    self.app.ui.start_update_pushButton.setEnabled(True)

            self.app.motor.odrv0.axis0.watchdog_feed()

        # Plot data
        self.app.plot_update_signal.emit()